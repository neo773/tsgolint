// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package no_unused_vars

import "github.com/go-json-experiment/json"
import "fmt"
import "reflect"

type NoUnusedVarsOptions struct {
	// Args corresponds to the JSON schema field "args".
	Args NoUnusedVarsOptionsArgs `json:"args,omitempty"`

	// ArgsIgnorePattern corresponds to the JSON schema field "argsIgnorePattern".
	ArgsIgnorePattern string `json:"argsIgnorePattern,omitempty"`

	// CaughtErrors corresponds to the JSON schema field "caughtErrors".
	CaughtErrors NoUnusedVarsOptionsCaughtErrors `json:"caughtErrors,omitempty"`

	// CaughtErrorsIgnorePattern corresponds to the JSON schema field
	// "caughtErrorsIgnorePattern".
	CaughtErrorsIgnorePattern string `json:"caughtErrorsIgnorePattern,omitempty"`

	// DestructuredArrayIgnorePattern corresponds to the JSON schema field
	// "destructuredArrayIgnorePattern".
	DestructuredArrayIgnorePattern string `json:"destructuredArrayIgnorePattern,omitempty"`

	// IgnoreClassWithStaticInitBlock corresponds to the JSON schema field
	// "ignoreClassWithStaticInitBlock".
	IgnoreClassWithStaticInitBlock bool `json:"ignoreClassWithStaticInitBlock,omitempty"`

	// IgnoreRestSiblings corresponds to the JSON schema field "ignoreRestSiblings".
	IgnoreRestSiblings bool `json:"ignoreRestSiblings,omitempty"`

	// ReportUsedIgnorePattern corresponds to the JSON schema field
	// "reportUsedIgnorePattern".
	ReportUsedIgnorePattern bool `json:"reportUsedIgnorePattern,omitempty"`

	// Vars corresponds to the JSON schema field "vars".
	Vars NoUnusedVarsOptionsVars `json:"vars,omitempty"`

	// VarsIgnorePattern corresponds to the JSON schema field "varsIgnorePattern".
	VarsIgnorePattern string `json:"varsIgnorePattern,omitempty"`
}

type NoUnusedVarsOptionsArgs string

const NoUnusedVarsOptionsArgsAfterUsed NoUnusedVarsOptionsArgs = "after-used"
const NoUnusedVarsOptionsArgsAll NoUnusedVarsOptionsArgs = "all"
const NoUnusedVarsOptionsArgsNone NoUnusedVarsOptionsArgs = "none"

var enumValues_NoUnusedVarsOptionsArgs = []interface{}{
	"all",
	"after-used",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NoUnusedVarsOptionsArgs) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NoUnusedVarsOptionsArgs {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NoUnusedVarsOptionsArgs, v)
	}
	*j = NoUnusedVarsOptionsArgs(v)
	return nil
}

type NoUnusedVarsOptionsCaughtErrors string

const NoUnusedVarsOptionsCaughtErrorsAll NoUnusedVarsOptionsCaughtErrors = "all"
const NoUnusedVarsOptionsCaughtErrorsNone NoUnusedVarsOptionsCaughtErrors = "none"

var enumValues_NoUnusedVarsOptionsCaughtErrors = []interface{}{
	"all",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NoUnusedVarsOptionsCaughtErrors) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NoUnusedVarsOptionsCaughtErrors {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NoUnusedVarsOptionsCaughtErrors, v)
	}
	*j = NoUnusedVarsOptionsCaughtErrors(v)
	return nil
}

type NoUnusedVarsOptionsVars string

const NoUnusedVarsOptionsVarsAll NoUnusedVarsOptionsVars = "all"
const NoUnusedVarsOptionsVarsLocal NoUnusedVarsOptionsVars = "local"

var enumValues_NoUnusedVarsOptionsVars = []interface{}{
	"all",
	"local",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NoUnusedVarsOptionsVars) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NoUnusedVarsOptionsVars {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NoUnusedVarsOptionsVars, v)
	}
	*j = NoUnusedVarsOptionsVars(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NoUnusedVarsOptions) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain NoUnusedVarsOptions
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		plain.Args = "after-used"
	}
	if v, ok := raw["argsIgnorePattern"]; !ok || v == nil {
		plain.ArgsIgnorePattern = ""
	}
	if v, ok := raw["caughtErrors"]; !ok || v == nil {
		plain.CaughtErrors = "all"
	}
	if v, ok := raw["caughtErrorsIgnorePattern"]; !ok || v == nil {
		plain.CaughtErrorsIgnorePattern = ""
	}
	if v, ok := raw["destructuredArrayIgnorePattern"]; !ok || v == nil {
		plain.DestructuredArrayIgnorePattern = ""
	}
	if v, ok := raw["ignoreClassWithStaticInitBlock"]; !ok || v == nil {
		plain.IgnoreClassWithStaticInitBlock = false
	}
	if v, ok := raw["ignoreRestSiblings"]; !ok || v == nil {
		plain.IgnoreRestSiblings = false
	}
	if v, ok := raw["reportUsedIgnorePattern"]; !ok || v == nil {
		plain.ReportUsedIgnorePattern = false
	}
	if v, ok := raw["vars"]; !ok || v == nil {
		plain.Vars = "all"
	}
	if v, ok := raw["varsIgnorePattern"]; !ok || v == nil {
		plain.VarsIgnorePattern = ""
	}
	*j = NoUnusedVarsOptions(plain)
	return nil
}
